#!/usr/bin/env python

import json
import sys
import datetime
import math

#let's define some default values for calculations
aspect_ratio= 1
core_utilization=0.7
default_micron=100

#refuse the used python version from the beginning
if (sys.version_info > (3, 0)):
    print('The Program doesnt support Python 3')
    exit(1)

#get the argumnents from CLI
#print(sys.argv[0])
if len(sys.argv) <4 and len(sys.argv)>=2:
    if(sys.argv[1]=='-help'):
        print('usage is python v2def jsonfilename leffile deffile\nyou can also add one of the following options:\n -a aspect_ratio\n'
              ' -u core_utilization\n -s site_width\n -h row_height\n -mh horizontal_magin\n -mv vertical_magin\n -gnd layer,width'
              '\n -vdd layer,width\n')
        exit(0)
    else:
        print ('usage is python v2def jsonfilename leffile deffile\nv2def -help for additional info')
        exit(1)
jsonfile=sys.argv[1]
leffile=sys.argv[2]
deffile=sys.argv[3]

#check for some of the input options by the user
#check for aspect ratio inputs
if ('-a' in sys.argv):
    aspect_ratio=float(sys.argv[sys.argv.index('-a')+1])
#check for core_utilization inputs
if ('-u' in sys.argv):
    core_utilization=float(sys.argv[sys.argv.index('-u')+1])

#print jsonfile
#jsonfile= raw_input('please enter the json file name [output of yosys]: ')

#Read JSON data into the datastore variable
if jsonfile:
    with open(jsonfile, 'r') as f:
        datastore = json.load(f)
designs_temp=datastore.items()[0]   #word modules
designs=designs_temp[1].keys()    #mux_4x1 or uart
pins_temp=designs_temp[1].values()  #get all attributes,cells,ports with their values
pins=pins_temp[0].items()[3]       #get the actual pins behaviour
components=pins_temp[0].items()[1]       #get all the cells
nets= pins_temp[0].items()[2]          #get all the actual nets
#print(nets)

#now read the lef file
#leffile=raw_input('please enter the lef file name: ')
#leffile_data=open(leffile,'r')

layer_names={'metal1','metal2','metal3','metal4','metal5','metal6'}
layers_orient_pitch={}
cells_sizes={}
vias={}
flag_found_layer_name=0 #used for parsing logic
flag_found_unit=0    #used for parsing logic
flag_found_cell_name=0  #used for parsing logic
flag_found_via_name=0
flag_unfinished_unit=1
flag_unfinished_cells=1
flag_unfinished_layers=1
flag_unfinished_vias=1

with open(leffile, 'r') as lf:
    for line in lf:
        try:
            first_word= line.split()[0]
            if(flag_unfinished_layers==1 and flag_unfinished_unit==0):
                #print "here"
                if (first_word == 'LAYER'):
                    try:
                        second_word=line.split()[1]
                        if (second_word in layer_names):
                            flag_found_layer_name=1
                            value_found_layer_name=second_word
                    except:
                        pass
                if (flag_found_layer_name ==1):
                    if(first_word == 'DIRECTION'):  #get the direction for this layer
                        try:
                            second_word=line.split()[1]
                            #print second_word
                            layers_orient_pitch[value_found_layer_name]=[]
                            if(second_word == 'HORIZONTAL'):
                                layers_orient_pitch[value_found_layer_name].append('Y') #make it Y as in the sample
                            elif(second_word == 'VERTICAL'):
                                layers_orient_pitch[value_found_layer_name].append('X') #make it Y as in the sample
                            else:
                                pass
                        except:
                            pass
                    elif(first_word == 'PITCH'):  #dont add until you find the pitch value
                        try:
                            second_word= line.split()[1]
                            layers_orient_pitch[value_found_layer_name].append(second_word) #add it to a list
                            #print layers_orient_pitch[value_found_layer_name]
                            #print "reacjed"
                            flag_found_layer_name=0
                        except:
                            pass
            if(flag_unfinished_unit==1):
                if(first_word == 'UNITS'):    #we then know for sure that the following line conntains the used micron anyways
                    flag_found_unit=1
                    flag_found_layer_name=0
                    flag_found_cell_name=0

                    #print "yeey"
                elif(flag_found_unit==1):
                    if (first_word == 'DATABASE'):
                        try:
                            second_word=line.split()[2]     #get the value of the microns
                            #print second_word
                            micron_value= int(second_word)
                            flag_found_unit=0
                            flag_unfinished_unit=0
                        except:
                            pass
            if(flag_unfinished_cells==1 and flag_unfinished_unit==0):
                if(first_word == 'MACRO'):    #we then know for sure that its one of the cells we need anyways
                    flag_unfinished_unit=0
                    flag_unfinished_vias=0
                    #print "got here"
                    try:
                         second_word=line.split()[1]     #get the name of needed cell
                         #print second_word
                         flag_found_cell_name=1
                         value_found_cell_name=second_word
                         flag_found_unit=0
                         flag_found_layer_name=0
                    except:
                        pass
                elif(flag_found_cell_name ==1):
                    if(first_word=='SIZE'):     #parse needed area; no need for all size
                        try:
                            #print "reached here"
                            second_word=line.split()[1]     #get the value of the cell width
                            area=float(second_word)
                            #print area
                            fourth_word=line.split()[3]     #get the value of the cell height
                            area=area*float(fourth_word)
                            cells_sizes[value_found_cell_name]=area
                            flag_found_cell_name=0
                        except:
                            pass
            if(flag_unfinished_vias==1 and flag_unfinished_cells==1 and flag_unfinished_unit==0):
                if (first_word== 'VIA'):
                    flag_unfinished_layers=0
                    try:
                        second_word=line.split()[1] #get the name of the via metal
                        flag_found_via_name=1
                        value_found_via_name =second_word
                        vias[value_found_via_name]={}
                    except:
                        pass
                if(flag_found_via_name):
                    if(first_word == 'LAYER'):
                        try:
                            name_of_the_layer=line.split()[1]
                            vias[value_found_via_name][name_of_the_layer]=[]
                        except:
                            pass
                    elif(first_word=='RECT'):
                        try:
                            for i in range(4):
                                #print i
                                vias[value_found_via_name][name_of_the_layer].append(line.split()[i+1])
                        except:
                            pass
                if(first_word== 'VIARULE'):
                    flag_unfinished_vias=0
            if(first_word== 'NAMESCASESENSITIVE'):
                try:
                    second_word=line.split()[1]
                    #print  second_word
                    if(second_word =='ON'):
                        namespace=1
                    else:
                        namespace=0
                except:
                    pass

        except:
            pass

# the following is a continutaion of the previous options taken by the user
#this is done here to ensure that all values are overwritten by the user's ones
#check for site_width inputs
if ('-s' in sys.argv):
    site_width=float(sys.argv[sys.argv.index('-s')+1])
#check for row_height inputs
if ('-h' in sys.argv):
    row_height=float(sys.argv[sys.argv.index('-h')+1])
#check for horizontal_magin inputs
if ('-mh' in sys.argv):
    horizontal_magin=float(sys.argv[sys.argv.index('-mh')+1])
#check for vertical_magin inputs
if ('-mv' in sys.argv):
    vertical_magin=float(sys.argv[sys.argv.index('-mv')+1])
#check for gnd inputs
if ('-gnd' in sys.argv):
    gnd=float(sys.argv[sys.argv.index('-gnd')+1])
#check for vdd inputs
if ('-vdd' in sys.argv):
    vdd=float(sys.argv[sys.argv.index('-vdd')+1])


# now write to the def file
#deffile=''
#deffile= deffile+jsonfile
#deffile=deffile+'.def'

#add this to header file
currenttime= datetime.datetime.now()
string_to_write='#Generated by Samanoudy Conversion Tool compiled on '+ str(currenttime)+'\n'
all_words=[]
all_words.append(string_to_write)

#add the version at the header of file
string_to_write='VERSION 5.7 ;'
all_words.append(string_to_write)

#now parse the Namespacecasesensitive thing
if(namespace):
    string_to_write='NAMESCASESENSITIVE ON ;'
else:
    string_to_write='NAMESCASESENSITIVE OFF ;'
all_words.append(string_to_write)

#now append the following to the header as well
string_to_write='DIVIDERCHAR "/" ;\nBUSBITCHARS "<>" ;'
all_words.append(string_to_write)

#append the design name
string_to_write='DESIGN '+designs[0]+' ;'
all_words.append(string_to_write)

#append the micron value
string_to_write='UNITS DISTANCE MICRONS '+str(default_micron)+' ;'
all_words.append(string_to_write)

#logic to calculate the whole area
ist=0   #iterator for parsing logic
total_area=0
while True:
    try:
        #print components[1].values()[ist]['type']
        component_name=components[1].values()[ist]['type']
        #print cells_sizes[component_name]
        total_area=total_area+int(cells_sizes[component_name])
        ist=ist+1
    except:
        break
#The actual total area is the following:
total_area=total_area*default_micron*default_micron
print total_area
actual_area= total_area
total_area=total_area/core_utilization
#depending on the aspect ratio
ycoordinate=math.floor(math.sqrt(total_area/aspect_ratio))
xcoordinates=math.floor(total_area/ycoordinate)
#xycoordinates=int(math.ceil(math.sqrt(total_area)))
total_height_core=int(math.ceil(math.sqrt(actual_area)))

#print xycoordinates
string_to_write='DIEAREA ( 0 0 ) ( '+str(int(xcoordinates))+' '+str(int(ycoordinate)) +' ) ;\n'
all_words.append(string_to_write)

#(TODO) here add the rows and Tracks

#add the vias section
string_to_write='VIAS '+str(len(vias))+' ;'
all_words.append(string_to_write)

#print vias.values()[0].values()[1][0]
for i in range(len(vias)):
    string_to_write='  '+'- '+vias.keys()[i]
    all_words.append(string_to_write)
    for ia in range(len(vias.values()[i])):
        string_to_write='  '+'+ RECT '+vias.values()[i].keys()[ia]+ ' ( '+str(float(vias.values()[i].values()[ia][i])\
                        *default_micron)+' '+ str(float(vias.values()[i].values()[ia][1])*default_micron) +' ) ( '+\
                        str(float(vias.values()[i].values()[ia][2])*default_micron)+' '+\
                        str(float(vias.values()[i].values()[ia][3])*default_micron)+' )'
        if (ia == len(vias.values()[0])-1):
            string_to_write=string_to_write+' ;'
        all_words.append(string_to_write)

with open(deffile, 'w') as f:
    for i in all_words:
        f.write(i+'\n')


'''
print 'design:: ',designs
print 'layers_orient_pitch:: ', layers_orient_pitch
print 'micron_value:: ', micron_value
print 'cell_areas::', cells_sizes
print 'vias_names::', vias
#print(datastore.keys()[0])
#print (datastore["modules"][0])
'''
